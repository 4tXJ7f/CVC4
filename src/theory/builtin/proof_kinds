//======================== Assume and Scope

// ======== Assumption (a leaf)
// Children: none
// Arguments: (F)
// --------------
// Conclusion: F
//
// This rule has special status, in that an application of assume is an
// open leaf in a proof that is not (yet) justified. An assume leaf is
// analogous to a free variable in a term, where we say "F is a free
// assumption in proof P" if it contains an application of F that is not
// bound by SCOPE (see below).
proofrule ASSUME 0 1 ::CVC4::theory::builtin::BuiltinProofRuleChecker

// ======== Assumption (a leaf)
// Children: (P:F)
// Arguments: (F1, ..., Fn)
// --------------
// Conclusion: (=> (and F1 ... Fn) F) or (not (and F1 ... Fn)) if F is false
//
// This rule has a dual purpose with ASSUME. It is a way to close
// assumptions in a proof. We require that F1 ... Fn are free assumptions in
// P and say that F1, ..., Fn are not free in (SCOPE P). In other words, they
// are bound by this application. For example, the proof node:
//   (SCOPE (ASSUME F) :args F)
// has the conclusion (=> F F) and has no free assumptions. More generally, a
// proof with no free assumptions always concludes a valid formula.
proofrule SCOPE 1 1: ::CVC4::theory::builtin::BuiltinProofRuleChecker

//======================== Node operations

// ======== Substitution
// Children: (P1:(= x1 t1), ..., Pn:(= xn tn))
// Arguments: (t)
// ---------------------------------------------------------------
// Conclusion: (= t t.substitute(x1,t1). ... .substitute(xn,tn))
// Notice that the orientation of the premises matters.
proofrule SUBS 1: 1 ::CVC4::theory::builtin::BuiltinProofRuleChecker

// ======== Rewrite
// Children: none
// Arguments: (t)
// ----------------------------------------
// Conclusion: (= t Rewriter::rewrite(t))
proofrule REWRITE 0 1 ::CVC4::theory::builtin::BuiltinProofRuleChecker

// ======== Substitution
// Children: (P1:(= x1 t1), ..., Pn:(= xn tn))
// Arguments: (t)
// ---------------------------------------------------------------
// Conclusion:
//  (= t Rewriter::rewrite(t.substitute(x1,t1). ... .substitute(xn,tn)))
proofrule SUBS_REWRITE 1: 1 ::CVC4::theory::builtin::BuiltinProofRuleChecker
