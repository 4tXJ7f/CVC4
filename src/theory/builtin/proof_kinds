//======================== Assume and Scope

// ======== Assumption (a leaf)
// Children: none
// Arguments: (F)
// --------------
// Conclusion: F
//
// This rule has special status, in that an application of assume is an
// open leaf in a proof that is not (yet) justified. An assume leaf is
// analogous to a free variable in a term, where we say "F is a free
// assumption in proof P" if it contains an application of F that is not
// bound by SCOPE (see below).
proofrule ASSUME 0 1 ::CVC4::theory::builtin::BuiltinProofRuleChecker

// ======== Assumption (a leaf)
// Children: (P:F)
// Arguments: (F1, ..., Fn)
// --------------
// Conclusion: (=> (and F1 ... Fn) F) or (not (and F1 ... Fn)) if F is false
//
// This rule has a dual purpose with ASSUME. It is a way to close
// assumptions in a proof. We require that F1 ... Fn are free assumptions in
// P and say that F1, ..., Fn are not free in (SCOPE P). In other words, they
// are bound by this application. For example, the proof node:
//   (SCOPE (ASSUME F) :args F)
// has the conclusion (=> F F) and has no free assumptions. More generally, a
// proof with no free assumptions always concludes a valid formula.
proofrule SCOPE 1 1: ::CVC4::theory::builtin::BuiltinProofRuleChecker

//======================== Node operations

// ======== Substitution
// Children: (P1:(= x1 t1), ..., Pn:(= xn tn))
// Arguments: (t)
// ---------------------------------------------------------------
// Conclusion: (= t t.substitute(xn,tn). ... .substitute(x1,t1))
// Notice that the orientation of the premises matters.
proofrule SUBS 1: 1 ::CVC4::theory::builtin::BuiltinProofRuleChecker

// ======== Rewrite
// Children: none
// Arguments: (t)
// ----------------------------------------
// Conclusion: (= t Rewriter::rewrite(t))
proofrule REWRITE 0 1 ::CVC4::theory::builtin::BuiltinProofRuleChecker

// NOTE: these technically rely on TRANS/TRUE_ELIM, which are UF, perhaps move?

// ======== Substitution + Rewriting equality introduction
// Children: (P1:(= x1 t1), ..., Pn:(= xn tn))
// Arguments: (t, id)
// ---------------------------------------------------------------
// Conclusion:
//  (= t Rewriter{id}(t.substitute(x1,t1). ... .substitute(xn,tn)))
macro MACRO_SR_EQ_INTRO 0: 1:2 ::CVC4::theory::builtin::BuiltinProofRuleChecker {
  (TRANS 
    (SUBS <children> t) 
    (REWRITE <t.substitute(x1,t1). ... .substitute(xn,tn)>))
}

// ======== Substitution + Rewriting predicate introduction
// Children: (P1:(= x1 t1), ..., Pn:(= xn tn))
// Arguments: (F, id)
// ---------------------------------------------------------------
// Conclusion:
//   F
// where Rewriter{id}(F.substitute(xn,tn). ... .substitute(x1,t1)) == true
macro MACRO_SR_PRED_INTRO 0: 1:2 ::CVC4::theory::builtin::BuiltinProofRuleChecker {
  (TRUE_ELIM 
    (MACRO_SR_EQ_INTRO <children> F))
}

// ======== Substitution + Rewriting predicate elimination
// Children: (P1:F, P2:(= x1 t1), ..., P_{n+1}:(= xn tn))
// Arguments: (id)
// ----------------------------------------
// Conclusion: Rewriter{id}(F.substitute(xn,tn). ... . substitute(x1,t1))
macro MACRO_SR_PRED_ELIM 1: 0:1 {
  (TRUE_ELIM 
    (TRANS 
      (SYMM (MACRO_SR_EQ_INTRO <children>[1:] F)) 
      (TRUE_INTRO <children>[0])))
}

// ======== Substitution + Rewriting predicate transform
// Children: (P1:F, P2:(= x1 t1), ..., P_{n+1}:(= xn tn))
// Arguments: (G, id)
// ----------------------------------------
// Conclusion: G
// where 
//   Rewriter{id}(F.substitute(xn,tn). ... . substitute(x1,t1)) ==
//   Rewriter{id}(G.substitute(xn,tn). ... . substitute(x1,t1))
macro MACRO_SR_PRED_TRANSFORM 1: 1:2 {
  (TRUE_ELIM 
    (TRANS 
      (MACRO_SR_EQ_INTRO <children>[1:] G)
      (SYMM (MACRO_SR_EQ_INTRO <children>[1:] F)) 
      (TRUE_INTRO <children>[0])))
}
