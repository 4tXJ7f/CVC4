
//======================== Core solver

// ======== Concat eq
// Children: (P1:(= (str.++ t1 ... tn t) (str.++ t1 ... tn s)))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion: (= t s)
//
// Notice that t or s may be empty, in which case they are implicit in the
// concatenation above. For example, if
// P1 concludes (= x (str.++ x z)), then
// (CONCAT_EQ P1 :args false) concludes (= "" z)
//
// Also note that constants are split, such that if
// P1 concludes (= (str.++ "abc" x) (str.++ "a" y)), then 
// (CONCAT_EQ P1 :args false) concludes (= (str.++ "bc" x) y)
// This splitting is done only for constants such that Word::splitConstant
// returns non-null.
proofrule CONCAT_EQ 1 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Concat unify
// Children: (P1:(= (str.++ t1 t2) (str.++ s1 s2)),
//            P2:(= (str.len t1) (str.len s1)))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion: (= t1 s1)
proofrule CONCAT_UNIFY 2 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Concat conflict
// Children: (P1:(= (str.++ c1 t) (str.++ c2 s)))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion: false
// Where c1, c2 are constants such that Word::splitConstant(c1,c2,...,b) 
// is null.
proofrule CONCAT_CONFLICT 2 1 ::CVC4::theory::strings::StringsProofRuleChecker


// ======== Concat split
// Children: (P1:(= (str.++ t1 t2) (str.++ s1 s2)),
//            P2:(not (= (str.len t1) (str.len s1))))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion:
// If b is false, then:
//   (or (= t1 (str.++ s1 r1)) (= s1 (str.++ t1 r2)))
// where
//   r1 = (witness ((z String)) (= z (suf t1 (str.len s1)))) and
//   r2 = (witness ((z String)) (= z (suf s1 (str.len t1)))).
//
// If b = true, then P1 is a proof of (= (str.++ t2 t1) (str.++ s2 s1)), and
// the conclusion is:
//   (or (= t1 (str.++ r1 s1)) (= s1 (str.++ r2 t1)))
// where
//   r1 = (witness ((z String)) (= z (pre t1 (- (str.len t) (str.len s1))))) and
//   r2 = (witness ((z String)) (= z (pre s1 (- (str.len s) (str.len t1))))).
// Above, (suf x n) is shorthand for (str.substr x n (- (str.len x) n)) and
// (pre x n) is shorthand for (str.substr x 0 n).
proofrule CONCAT_SPLIT 2 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Concat split propagate
// Children: (P1:(= (str.++ t1 t2) (str.++ s1 s2)),
//            P2:(> (str.len t1) (str.len s1)))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion: (= t1 (str.++ s1 r1))
// where
// TODO
proofrule CONCAT_LPROP 2 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Concat split propagate
// Children: (P1:(= (str.++ t1 w1 t2) (str.++ w2 s1)))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion: (= t1 (str.++ w3 ...)) where w3 ++ w4 = w1 and w4 is the
// overlap of w1 and w2.
proofrule CONCAT_CPROP 1 1 ::CVC4::theory::strings::StringsProofRuleChecker


//======================== Extended functions

// ======== Contains not equal
// Children: (P1:(not (str.contains s t)))
// Arguments: none
// -------------------
// Conclusion: (not (= s t))
proofrule CTN_NOT_EQUAL 1 0 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Reduction
// Children: none
// Arguments: (t)
// ---------------------
// Conclusion: (and R (= t w)) 
// where w = StringsPreprocess::reduce(t, R, ...).
// In other words, R is the reduction predicate for extended term t, and w is
//   (witness ((z T)) (= z t))
// Notice that the free variables of R are w and the free variables of t.
proofrule STRINGS_REDUCTION 0 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Eager Reduction
// Children: none
// Arguments: (t)
// ---------------------
// Conclusion: R
// where R = StringsPreprocess::eagerReduce(t).
// In other words, R is the reduction predicate for extended term t[x], and w is
//   (witness ((z T)) (= z t[x]))
proofrule STRINGS_EAGER_REDUCTION 0 1 ::CVC4::theory::strings::StringsProofRuleChecker

//======================== Regular expressions

// ======== Regular expression intersection
// Children: (P1:(str.in.re t R1), ..., Pn:(str.in.re t Rn))
// Arguments: none
// ---------------------
// Conclusion: (str.in.re t (re.inter R1 ... Rn))
proofrule RE_INTER 2: 0 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Regular expression unfold positive
// Children: (P:(str.in.re t R)) 
// Arguments: none
// ---------------------
// Conclusion:(RegExpOpr::reduceRegExpPos(t,R)),
// corresponding to the one-step unfolding of the premise.
proofrule RE_UNFOLD_POS 1 0 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Regular expression unfold negative
// Children: (P:(not (str.in.re t R)))
// Arguments: none
// ---------------------
// Conclusion:(RegExpOpr::reduceRegExpNeg(t,R)), 
// corresponding to the one-step unfolding of the premise.
proofrule RE_UNFOLD_NEG 1 0 ::CVC4::theory::strings::StringsProofRuleChecker
