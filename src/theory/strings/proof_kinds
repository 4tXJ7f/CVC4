
//======================== Core solver

// ======== Concat endpoint unify
// Children: (P1:(= (str.++ r t1) (str.++ r s1)))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion: (= t1 s1)
CONCAT_ENDP_UNIFY 1 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Normal form unify
// Children: (P1:(= (str.++ t1 t2) (str.++ s1 s2)),
//            P2:(= (str.len t1) (str.len s1)))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion: (= t1 s1)
CONCAT_UNIFY 2 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Concat split
// Children: (P1:(= (str.++ t1 t2) (str.++ s1 s2)),
//            P2:(not (= (str.len t1) (str.len s1))))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion:
// If b is false, then:
//   (or (= t1 (str.++ s1 r1)) (= s1 (str.++ t1 r2)))
// where
//   r1 = (witness ((z String)) (= z (suf t1 (str.len s1)))) and
//   r2 = (witness ((z String)) (= z (suf s1 (str.len t1)))).
// If b = true, then:
//   (or (= t1 (str.++ r1 s1)) (= s1 (str.++ r2 t1)))
// where
//   r1 = (witness ((z String)) (= z (pre t1 (str.len s1)))) and
//   r2 = (witness ((z String)) (= z (pre s1 (str.len t1)))).
// Above, (suf x n) is shorthand for (str.substr x n (- (str.len x) n)) and
// (pre x n) is shorthand for (str.substr x 0 n).
CONCAT_SPLIT 2 1 ::CVC4::theory::strings::StringsProofRuleChecker

// ======== Concat split propagate
// Children: (P1:(= (str.++ t1 t2) (str.++ s1 s2)),
//            P2:(> (str.len t1) (str.len s1)))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion: (= t1 (str.++ s1 ...))
CONCAT_LPROP

// ======== Concat split propagate
// Children: (P1:(= (str.++ t1 w1 t2) (str.++ w2 s1)))
// Arguments: (b), indicating if reverse direction
// ---------------------
// Conclusion: (= t1 (str.++ w3 ...)) where w3 ++ w4 = w1 and w4 is the
// overlap of w1 and w2.
CONCAT_CPROP


//======================== Extended functions

// ======== Contains not equal
// Children: (P1:(not (str.contains s t)))
// Arguments: none
// -------------------
// Conclusion: (not (= s t))
CTN_NOT_EQUAL

// ======== Reduction
// Children: none
// Arguments: (t[x])
// ---------------------
// Conclusion: (and R[x,y] (= t[x] y)) where R is the reduction predicate
// for extended term t[x].
REDUCTION

//======================== Regular expressions

// ======== Regular expression intersection
// Children: (P:(str.in.re t R1), P:(str.in.re t R2))
// Arguments: none
// ---------------------
// Conclusion: (str.in.re t (re.inter R1 R2)).
RE_INTER

// ======== Regular expression unfold
// Children: (P:(str.in.re t R)) or (P:(not (str.in.re t R)))
// Arguments: none
// ---------------------
// Conclusion:F, corresponding to the one-step unfolding of the premise.
RE_UNFOLD
