/******************************************************************************
 * Core
 ******************************************************************************/

/* ConcatFlatten: FLATTEN IMPLICIT */

/* ConcatExtractMerge */

/* ConcatConstantMerge */

(define-rule ExtractWhole ((i Int :const) (n Int :const) (x (_ BitVec n)))
  ((_ extract i 0) x)
  (cond 
    ((= i (- n 1)) x)))

/* ExtractConcat */

(define-rule ExtractExtract ((i Int :const) (j Int :const) (k Int :const) (l Int :const) (x (_ BitVec n)))
  ((_ extract i j) ((_ extract k l) x))
  ((_ extract (+ k j) (+ l j)) x))

(define-rule SimplifyEq ((x (_ BitVec n)))
  (= x x)
  true)

/******************************************************************************
 * Normalization
 ******************************************************************************/

(define-rule ExtractNot ((i Int :const) (j Int :const) (x (_ BitVec n)))
  ((_ extract i j) (bvnot x))
  (bvnot ((_ extract i j) x)))

(define-rule ExtractSignExtend ((i Int :const) (j Int :const) (k Int :const) (n Int :const) (x (_ BitVec n)))
  ((_ extract i j) ((_ sign_extend k) x))
  (cond
    ((< i n) ((_ extract i j) x))
    ((and (< j n) (>= i n)) ((_ sign_extend (+ (- i n) 1)) ((_ extract (- n 1) j) x)))
    (true ((_ repeat (+ (- i j) 1)) ((_ extract (- n 1) (- n 1)) x)))))

/******************************************************************************
 * Operator Elimination
 ******************************************************************************/

(define-rule UgtEliminate ((x (_ BitVec n)) (y (_ BitVec n)))
    (bvugt x y)
    (bvult y x))

(define-rule UgeEliminate ((x (_ BitVec n)) (y (_ BitVec n)))
    (bvuge x y)
    (bvule y x))

(define-rule SgtEliminate ((x (_ BitVec n)) (y (_ BitVec n)))
    (bvsgt x y)
    (bvslt y x))

(define-rule SgeEliminate ((x (_ BitVec n)) (y (_ BitVec n)))
    (bvsge x y)
    (bvsle y x))

(define-rule SltEliminate ((n Int :const) (x (_ BitVec n)) (y (_ BitVec n)))
    (bvslt x y)
    (let ((pow_two (bvshl (_ bv 1 n) (_ bv (- n 1) n))))
      (bvult (bvadd x pow_two) (bvadd y pow_two))))

(define-rule SleEliminate ((x (_ BitVec n)) (y (_ BitVec n)))
    (bvsle x y)
    (not (bvslt y x)))

(define-rule UleEliminate ((x (_ BitVec n)) (y (_ BitVec n)))
    (bvule x y)
    (not (bvult y x)))

(define-rule CompEliminate ((x (_ BitVec n)) (y (_ BitVec n)))
   (bvcomp x y)
   (ite (= x y) (_ bv 1 1) (_ bv 0 1)))

(define-rule SubEliminate ((x (_ BitVec n)) (y (_ BitVec n)))
    (bvsub x y)
    (bvadd x (bvneg y)))

/* RepeatEliminate: Worth it? */

(define-rule RotateLeftEliminate ((i Int :const) (n Int :const) (x (_ BitVec n)))
    ((_ rotate_left i) x)
    (cond
      ((= i 0) x)
      (concat ((_ extract (- n (+ 1 i)) 0) x) ((_ extract (- n 1) (- n i)) x))))

(define-rule RotateRightEliminate ((i Int :const) (n Int :const) (x (_ BitVec n)))
    ((_ rotate_right i) x)
    (cond
      ((= i 0) x)
      (concat ((_ extract (- i 1) 0) x) ((_ extract (- n 1) i) x))))

/* BVToNatEliminate: COMPLEX */

/* IntToBVEliminate: COMPLEX */

(define-rule NandEliminate ((x (_ BitVec n)) (y (_ BitVec n)))
    (bvnand x y)
    (bvnot (bvand x y)))

(define-rule NorEliminate ((x (_ BitVec n)) (y (_ BitVec n)))
    (bvnor x y)
    (bvnot (bvor x y)))

(define-rule XnorEliminate ((x (_ BitVec n)) (y (_ BitVec n)))
    (bvxnor x y)
    (bvnot (bvxor x y)))

(define-rule SdivEliminate ((n Int :const) (x (_ BitVec n)) (y (_ BitVec n)))
  (bvsdiv x y)
  (let ((x_lt_0 (= ((_ extract (- n 1) (- n 1)) x) (_ bv 1 1)))
        (y_lt_0 (= ((_ extract (- n 1) (- n 1)) y) (_ bv 1 1)))
        (abs_x (ite x_lt_0 (bvneg x) x))
        (abs_y (ite y_lt_0 (bvneg y) y))
        (x_udiv_y (bvudiv abs_x abs_y)))
    (ite (xor x_lt_0 y_lt_0)
      (bvneg x_udiv_y)
      x_udiv_y)))

(define-rule SremEliminate ((n Int :const) (x (_ BitVec n)) (y (_ BitVec n)))
  (bvsrem x y)
  (let ((x_lt_0 (= ((_ extract (- n 1) (- n 1)) x) (_ bv 1 1)))
        (y_lt_0 (= ((_ extract (- n 1) (- n 1)) y) (_ bv 1 1)))
        (abs_x (ite x_lt_0 (bvneg x) x))
        (abs_y (ite y_lt_0 (bvneg y) y))
        (x_urem_y (bvurem abs_x abs_y)))
    (ite x_lt_0
      (bvneg x_urem_y)
      x_urem_y)))

(define-rule SmodEliminate ((n Int :const) (x (_ BitVec n)) (y (_ BitVec n)))
  (bvsmod x y)
  (let ((msb_x ((_ extract (- n 1) (- n 1)) x))
        (msb_y ((_ extract (- n 1) (- n 1)) y))
        (x_lt_0 (= msb_x (_ bv 1 1)))
        (y_lt_0 (= msb_y (_ bv 1 1)))
        (abs_x (ite x_lt_0 (bvneg x) x))
        (abs_y (ite y_lt_0 (bvneg y) y))
        (x_urem_y (bvurem abs_x abs_y)))
    (ite (= x_urem_y (_ bv 0 n))
      x_urem_y
      (ite (and (= msb_x (_ bv 0 1)) (= msb_y (_ bv 0 1)))
        x_urem_y
        (ite (and (= msb_x (_ bv 1 1)) (= msb_y (_ bv 0 1)))
          (bvadd (bvneg x_urem_y) y)
          (ite (and (= msb_x (_ bv 0 1)) (= msb_y (_ bv 1 1)))
            (bvadd x_urem_y y)
            (bvneg x_urem_y)))))))

(define-rule ZeroExtendEliminate ((i Int :const) (x (_ BitVec n)))
  ((_ zero_extend i) x)
  (cond
    ((= i 0) x)
    (concat (_ bv 0 i) x)))

(define-rule SignExtendEliminate ((i Int :const) (n Int :const) (x (_ BitVec n)))
  ((_ sign_extend i) x)
  (cond
    ((= i 0) x)
    (concat ((_ repeat i) ((_ extract (- n 1) (- n 1)) x)) x)))

(define-rule RedorEliminate ((n Int :const) (x (_ BitVec n)))
    (bvredor x)
    (not (= x (_ bv 0 n))))

(define-rule RedandEliminate ((n Int :const) (x (_ BitVec n)))
    (bvredand x)
    (= x (bvnot (_ bv 0 n))))

/******************************************************************************
 * Simplification
 ******************************************************************************/

(define-rule BvIteConstCond ((m Int :const) (x (_ BitVec n)) (y (_ BitVec n)))
  (bvite (_ bv m 1) x y)
  (cond
    ((= m 1) x)
    y))

(define-rule BvIteEqualChildren ((c (_ BitVec 1)) (x (_ BitVec m)))
  (bvite c x x)
  x)

(define-rule BvIteConstChildren ((n Int :const) (m Int :const) (x (_ BitVec o)))
  (bvite x (_ bv n 1) (_ bv m 1))
  (cond
    ((and (= n 1) (= m 0)) x)
    (true (bvnot x))))

(define-rule BvIteEqualCondThen ((c (_ BitVec 1)) (x (_ BitVec n)) (y (_ BitVec n)) (z (_ BitVec n)))
  (bvite c (bvite c x y) z)
  (bvite c x z))

(define-rule BvIteEqualCondElse ((c (_ BitVec 1)) (x (_ BitVec n)) (y (_ BitVec n)) (z (_ BitVec n)))
  (bvite c x (bvite c y z))
  (bvite c x z))

(define-rule BvIteMergeThenIf ((c0 (_ BitVec 1)) (c1 (_ BitVec 1)) (x (_ BitVec n)) (y (_ BitVec n)))
  (bvite c0 (bvite c1 x y) x)
  (bvite (bvand c0 (bvnot c1)) y x))

(define-rule BvIteMergeElseIf ((c0 (_ BitVec 1)) (c1 (_ BitVec 1)) (x (_ BitVec n)) (y (_ BitVec n)))
  (bvite c0 (bvite c1 x y) y)
  (bvite (bvand c0 c1) x y))

(define-rule BvIteMergeThenElse ((c0 (_ BitVec 1)) (c1 (_ BitVec 1)) (x (_ BitVec n)) (y (_ BitVec n)))
  (bvite c0 x (bvite c1 x y))
  (bvite (bvand (bvnot c0) (bvnot c1)) y x))

(define-rule BvIteMergeElseElse ((c0 (_ BitVec 1)) (c1 (_ BitVec 1)) (x (_ BitVec n)) (y (_ BitVec n)))
  (bvite c0 x (bvite c1 y x))
  (bvite (bvand (bvnot c0) c1) y x))

(define-rule BvComp ((n Int :const) (x (_ BitVec 1)))
  (bvcomp (_ bv n 1) x)
  (cond
    ((= n 0) (bvnot x))
    x))

(define-rule ShlByConst ((n Int :const) (m Int :const) (x (_ BitVec m)))
  (bvshl x (_ bv n m))
  (cond
    ((= n 0) x)
    ((>= n m) (_ bv 0 m))
    (concat ((_ extract (- m (+ n 1)) 0) x) (_ bv 0 n))))

/*
(define-rule XorOne ((n Int :const) (xs (_ BitVec n) :list))
  (bvxor (bvnot (_ bv 0 n)) xs)
  (bvxor xs))
*/

(define-rule XorZero ((n Int :const) (xs (_ BitVec n) :list))
  (bvxor (_ bv 0 n) xs)
  (bvxor xs))

(define-rule NotXor ((x (_ BitVec n)) (xs (_ BitVec n) :list))
  (bvnot (bvxor x xs))
  (bvxor (bvnot x) xs))

(define-rule NotIdemp ((x (_ BitVec n)))
    (bvnot (bvnot x))
    x)

(define-rule LtSelfUlt ((x (_ BitVec n)))
    (bvult x x)
    false)

(define-rule LtSelfSlt ((x (_ BitVec n)))
    (bvslt x x)
    false)

(define-rule LteSelfUle ((x (_ BitVec n)))
    (bvule x x)
    true)

(define-rule LteSelfSle ((x (_ BitVec n)))
    (bvsle x x)
    true)

(define-rule ZeroUlt ((n Int :const) (x (_ BitVec n)))
    (bvult (_ bv 0 n) x)
    (not (= (_ bv 0 n) x)))

(define-rule UltZero ((n Int :const) (x (_ BitVec n)))
    (bvult x (_ bv 0 n))
    false)

(define-rule UltOne ((n Int :const) (x (_ BitVec n)))
    (bvult x (_ bv 1 n))
    (= x (_ bv 0 n)))

(define-rule SltZero ((n Int :const) (x (_ BitVec n)))
    (bvslt x (_ bv 0 n))
    (= ((_ extract (- n 1) (- n 1)) x) (_ bv 1 1)))

/* Note: Duplicate of LtSelfUlt */
(define-rule UltSelf ((x (_ BitVec n)))
    (bvult x x)
    false)

(define-rule UleZero ((n Int :const) (x (_ BitVec n)))
    (bvule x (_ bv 0 n))
    (= x (_ bv 0 n)))

/* Note: Duplicate of LteSelfUle */
(define-rule UleSelf ((x (_ BitVec n)))
    (bvule x x)
    true)

(define-rule ZeroUle ((n Int :const) (x (_ BitVec n)))
    (bvule (_ bv 0 n) x)
    true)

(define-rule NotUlt ((x (_ BitVec n)) (y (_ BitVec n)))
    (not (bvult x y))
    (bvule y x))

(define-rule UleMax ((n Int :const) (x (_ BitVec n)))
    (bvult x (bvnot (_ bv 0 n)))
    true)

(define-rule NotUle ((x (_ BitVec n)) (y (_ BitVec n)))
    (not (bvule x y))
    (bvult y x))

(define-rule NegIdemp ((n Int :const) (x (_ BitVec n)))
    (bvneg (bvneg x))
    x)

/* UdivPow2 */

(define-rule UdivZero ((n Int :const) (x (_ BitVec n)))
    (bvudiv x (_ bv 0 n))
    (bvnot (_ bv 0 n)))

(define-rule UdivOne ((n Int :const) (x (_ BitVec n)))
    (bvudiv x (_ bv 1 n))
    x)

(define-rule UremOne ((n Int :const) (x (_ BitVec n)))
    (bvudiv x (_ bv 1 n))
    (_ bv 0 n))

(define-rule UremSelf ((n Int :const) (x (_ BitVec n)))
    (bvudiv x x)
    (_ bv 0 n))

(define-rule ShiftZeroShl ((n Int :const) (x (_ BitVec n)))
    (bvshl (_ bv 0 n) x)
    (_ bv 0 n))

(define-rule ShiftZeroLshr ((n Int :const) (x (_ BitVec n)))
    (bvlshr (_ bv 0 n) x)
    (_ bv 0 n))

(define-rule ShiftZeroAshr ((n Int :const) (x (_ BitVec n)))
    (bvashr (_ bv 0 n) x)
    (_ bv 0 n))

(define-rule MergeSignExtendSign ((i Int :const) (j Int :const) (n Int :const) (x (_ BitVec n)))
  ((_ sign_extend i) ((_ sign_extend j) x))
  ((_ sign_extend (+ i j)) x))

(define-rule MergeSignExtendZero ((i Int :const) (j Int :const) (n Int :const) (x (_ BitVec n)))
  ((_ sign_extend i) ((_ zero_extend j) x))
  (cond
    ((= j 0) ((_ sign_extend i) x))
    (true ((_ zero_extend (+ i j)) x))))

(define-rule ZeroExtendEqConst ((i Int :const) (n Int :const) (m Int :const) (x (_ BitVec n)))
  (= ((_ zero_extend i) x) (_ bv m n))
  (cond
    ((= ((_ extract (- (+ n m) 1) n) (_ bv m n)) (_ bv 0 n)) (= x ((_ extract (- n 1) 0) (_ bv m n))))
    false))

(define-rule UltPlusOne ( (n Int :const) (x (_ BitVec n)) (y (_ BitVec n)))
  (bvult x (bvadd y (_ bv 1 n)))
  (and (bvult (bvnot y) x) (not (= y (bvnot (_ bv 0 n))))))

/******************************************************************************
 * Experimental
 ******************************************************************************/

/*
(define-rule LteSelfUle ((x (_ BitVec n)))
    (bvule x x)
    true)

(define-rule NegIdemp ((n Int :const) (x (_ BitVec n)))
    (bvneg (bvneg x))
    x)

(define-rule ZeroExtendEliminate ((i Int :const) (x (_ BitVec n)))
  ((_ zero_extend i) x)
  (cond
    ((= i 0) x)
    (concat (_ bv 0 i) x)))


(define-rule UleMax ((n Int :const) (x (_ BitVec n)))
    (bvule x (bvnot (_ bv 0 n)))
    true)

(define-rule AndCancel ((x Bool) (xs Bool :list))
    (and x (not x) xs)
    false)

(define-rule AndRemDups ((x Bool) (xs Bool :list))
    (and x x xs)
    (and xs))

(define-rule IffTrue ((x Bool))
  (= true x)
  x)

(define-rule IffFalse ((x Bool))
  (= true x)
  (not x))

(define-rule IffSelf ((x Bool))
  (= x x)
  true)

(define-rule IffCancel ((x Bool))
  (= x (not x))
  false)
*/

/* Double eq rules */


/*
(define-rule XorTrue ((x Bool))
  (xor true x)
  (not x))

(define-rule XorFalse ((x Bool))
  (xor false x)
  x)

(define-rule XorSelf ((x Bool))
  (xor x x)
  false)

(define-rule XorSelfNeg ((x Bool))
  (xor x (not x))
  true)
*/

/*
(define-rule IffCancel ((x Bool) (xs (List Bool)))
    (and x (not x) xs)
    false)

(define-rule IffCancel ((x Bool) (xs Bool :list))
    (and x (not x) xs)
    false)

; (declare-const x Bool)
; (declare-const xs Bool)
; (assert (not (= (and x (not x) xs) false)))
; (check-sat)
;
; ^^^
; Make argument for why it is sufficient to only check this form

; :list/:multiple

(define-rule IffCancel ((x Bool))
    (! and x x :binary)
    x)

; (and t t s u)
; (and t (and t (and s u)))
; (and (and (and t t) s) u)

; have an attribute for fixed number of children

(define-rule IffCancelTwo ((x Bool))
    (= (not x) x)
    false)

; (declare-rule ...)
; (define-strategy
; ...
; )
*/
